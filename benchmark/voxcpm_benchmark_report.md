# VoxCPM 1.5 显存优化与性能测试报告

**测试时间**: 2025-12-14
**测试环境**: 4× GPU (3,4,5,6)，分 2 组，每组 2 卡
**模型**: VoxCPM 1.5 (44.1kHz)

---

## 推荐配置（默认）

```bash
VOXCPM_GPU_MEMORY_UTILIZATION=0.4
VOXCPM_MAX_NUM_SEQS=128
VOXCPM_MAX_MODEL_LEN=2048

# 性能指标:
# - 显存: ~7.4 GB/卡
# - 最大并发: 128
# - 满载吞吐: 157x
# - 支持最长文本: ~300字
```

---

## 1. 背景与目标

### 1.1 问题描述

VoxCPM 1.5 默认配置下，每张 GPU 显存占用超过 20GB，导致资源浪费。

### 1.2 根因分析

显存占用主要由 KV Cache 预分配决定，受三个参数控制：

| 参数 | 默认值 | 作用 |
|------|--------|------|
| `gpu_memory_utilization` | 0.9 | GPU 显存利用率上限 |
| `max_num_seqs` | 512 | 最大并发序列数 |
| `max_model_len` | 4096 | 最大序列长度 |

### 1.3 测试目标

1. 找出最低可用的 `gpu_memory_utilization`
2. 测量满负载下的实际性能（吞吐量、RTF、TTFB）
3. 验证超并发时的排队机制
4. 测试 `max_model_len` 对长文本的影响

---

## 2. 测试配置

### 2.1 硬件配置

```
服务器: 172.16.10.201
GPU: NVIDIA GPU × 8 (使用 3,4,5,6 四张)
分组:
  - group0: GPU 3,4 → port 8081
  - group1: GPU 5,6 → port 8082
```

### 2.2 软件配置

```
模型: VoxCPM 1.5
采样率: 44100 Hz
推理框架: vLLM-based (nanovllm-voxcpm)
Python: /home/estar/miniconda3/envs/voxcpm
```

---

## 3. 极限 util 测试

### 3.1 测试目的

找出 `seqs=128` 下最低可用的 `gpu_memory_utilization`。

### 3.2 测试结果

| util | seqs | 启动状态 | 显存/卡 | 备注 |
|------|------|----------|---------|------|
| 0.50 | 128 | ✓ 成功 | 10,669 MB | 之前认为的最低值 |
| 0.45 | 128 | ✓ 成功 | 8,582 MB | |
| **0.40** | **128** | **✓ 成功** | **7,432 MB** | **实际最低可用** |
| 0.35 | 128 | ✗ 失败 | - | KV Cache 不足 |

### 3.3 util=0.4 性能验证

| 测试项 | 结果 |
|--------|------|
| 空载显存 | 7,432 MB/卡 |
| 单请求 RTF | 0.11 |
| 64 并发吞吐 | 123x |
| 128 并发吞吐 | 157x |
| 128 并发成功率 | 100% |

### 3.4 结论

- **最低可用 util = 0.4**
- 相比 util=0.5，显存节省 30%（10.7GB → 7.4GB）
- 吞吐量仅下降 5%（166x → 157x）

---

## 4. max_model_len 测试

### 4.1 测试目的

验证 `max_model_len` 对显存和长文本支持的影响。

### 4.2 测试配置

```
util = 0.4
seqs = 128
测试文本:
  - 短文本: 8 字
  - 中文本: 68 字
  - 长文本: 313 字
```

### 4.3 测试结果

| max_model_len | 显存/卡 | 短文本(8字) | 中文本(68字) | 长文本(313字) |
|---------------|---------|-------------|--------------|---------------|
| 2048 | 7,432 MB | ✓ 1.9s | ✓ 13.1s | ✓ 60.2s |
| 1024 | 7,432 MB | ✓ 1.9s | ✓ 13.6s | ✓ 68.2s |
| 512 | 7,520 MB | ✓ 2.4s | ✓ 13.3s | ✗ 失败 |
| 256 | 7,462 MB | ✓ 1.9s | ✓ 13.8s | ✗ 失败 |

### 4.4 关键发现

1. **显存几乎不变** - 从 2048 降到 256，显存仍是 ~7.4GB
   - 原因：在 util=0.4 时，显存已被 util 限制

2. **长文本需要足够的 len**
   - 313 字需要 > 512 tokens → `len≥1024`
   - 68 字需要 < 256 tokens → `len=256` 足够

3. **中文字符到 tokens 换算**（粗略）
   ```
   中文字符 → tokens ≈ 1:2~3
   ```

### 4.5 max_model_len 选择指南

| 业务场景 | 文本长度 | 推荐 len |
|----------|----------|----------|
| 短句 TTS | < 50 字 | 512 |
| 段落 TTS | < 200 字 | 1024 |
| 长文章 TTS | < 500 字 | 2048 |

---

## 5. 不同 util 级别的极限并发测试

### 5.1 测试方法

对每个 `util` 级别，递增 `seqs` 直到启动失败（OOM）。

### 5.2 util = 0.5

| seqs | 启动 | 空载显存/卡 | 满载吞吐量 | RTF | 成功率 |
|------|------|-------------|------------|-----|--------|
| 8 | ✓ | 10,253 MB | 48.4x | 0.021 | 100% |
| 16 | ✓ | 10,265 MB | 93.9x | 0.021 | 100% |
| 32 | ✓ | 10,295 MB | 126.1x | 0.031 | 100% |
| 64 | ✓ | 10,355 MB | 151.2x | 0.051 | 100% |
| 128 | ✓ | 10,669 MB | 166.5x | 0.093 | 100% |

### 5.3 util = 0.7

| seqs | 启动 | 空载显存/卡 | 满载吞吐量 | RTF | 成功率 |
|------|------|-------------|------------|-----|--------|
| 8 | ✓ | 14,573 MB | 48.7x | 0.021 | 100% |
| 16 | ✓ | 14,593 MB | 94.2x | 0.021 | 100% |
| 32 | ✓ | 14,633 MB | 129.9x | 0.030 | 100% |
| 64 | ✓ | 14,701 MB | 152.7x | 0.050 | 100% |
| 128 | ✓ | 14,843 MB | 163.9x | 0.095 | 100% |

### 5.4 util = 0.9

| seqs | 启动 | 空载显存/卡 | 满载吞吐量 | RTF | 成功率 |
|------|------|-------------|------------|-----|--------|
| 8 | ✓ | 18,893 MB | 48.9x | 0.020 | 100% |
| 16 | ✓ | 18,913 MB | 94.9x | 0.021 | 100% |
| 32 | ✓ | 18,961 MB | 131.9x | 0.030 | 100% |
| 64 | ✓ | 19,057 MB | 152.9x | 0.050 | 100% |
| 128 | ✓ | 19,239 MB | 169.6x | 0.091 | 100% |

### 5.5 关键发现

1. **所有 util 级别都支持 seqs=128**
2. **seqs 对显存影响很小**（从 8 到 128 仅增加 ~400MB）
3. **显存主要由 util 决定**

---

## 6. TTFB（首字延迟）测试

### 6.1 测试配置

```
util = 0.5
seqs = 128
测试文本: "人工智能技术正在快速发展。"
```

### 6.2 测试结果

| 并发数 | TTFB min | TTFB avg | TTFB max |
|--------|----------|----------|----------|
| 1 | 357ms | 357ms | 357ms |
| 8 | 565ms | 583ms | 601ms |
| 32 | 660ms | 885ms | 974ms |
| 64 | 1,274ms | 1,319ms | 1,357ms |
| 128 | 1,650ms | 1,830ms | 2,013ms |

### 6.3 分析

- **单请求 TTFB**: ~350ms（基准延迟）
- **满载 TTFB**: ~1.8s（128 并发）
- **TTFB 随并发线性增长** - 符合 batch 处理特性

---

## 7. 超并发测试（排队机制验证）

### 7.1 测试目的

验证当并发数超过 `max_num_seqs` 时的系统行为。

### 7.2 测试配置

```
util = 0.5
seqs = 128
测试并发: 64, 128, 192, 256
```

### 7.3 测试结果

| 并发数 | 负载率 | 成功率 | Wall Time | TTFB avg | TTFB max |
|--------|--------|--------|-----------|----------|----------|
| 64 | 50% | 100% | 1.9s | 1,209ms | 1,334ms |
| 128 | 100% | 100% | 3.0s | 1,905ms | 1,989ms |
| 192 | 150% | 100% | 4.2s | 2,361ms | 2,618ms |
| 256 | 200% | 100% | 5.2s | 3,049ms | 3,303ms |

### 7.4 TTFB 分布分析

| 并发数 | 前 25% avg | 后 25% avg | 差值 |
|--------|------------|------------|------|
| 64 | 1,096ms | 1,325ms | 229ms |
| 128 | 1,839ms | 1,971ms | 132ms |
| 192 | 2,134ms | 2,592ms | 458ms |
| 256 | 2,849ms | 3,259ms | 410ms |

### 7.5 关键发现

1. **不会拒绝请求** - 256 并发全部成功
2. **不会 OOM** - KV Cache 已预分配，超出的请求排队等待
3. **Wall Time 线性增长** - 256 并发约为 128 并发的 1.7 倍
4. **排队效应明显** - 后 25% 请求 TTFB 比前 25% 多 400ms+

---

## 8. 配置对比汇总

### 8.1 不同 util 配置对比

| 配置 | 显存/卡 | 最大并发 | 满载吞吐 | 推荐场景 |
|------|---------|----------|----------|----------|
| **util=0.4, seqs=128** | **7.4 GB** | **128** | **157x** | **默认推荐** |
| util=0.5, seqs=128 | 10.7 GB | 128 | 166x | 需要更高吞吐 |
| util=0.7, seqs=128 | 14.8 GB | 128 | 164x | 显存充足时 |
| util=0.9, seqs=128 | 19.2 GB | 128 | 170x | 追求极限性能 |

### 8.2 显存节省对比

```
默认配置 (util=0.9):  19.2 GB/卡
优化配置 (util=0.4):   7.4 GB/卡
────────────────────────────────
节省显存:             11.8 GB/卡 (61%)
吞吐量损失:            ~7% (170x → 157x)
```

---

## 9. 配置选择指南

### 9.1 按显存选择

| 可用显存 | 推荐配置 | 最大并发 | 吞吐量 |
|----------|----------|----------|--------|
| 8 GB | util=0.4, seqs=128 | 128 | 157x |
| 12 GB | util=0.5, seqs=128 | 128 | 166x |
| 16 GB | util=0.7, seqs=128 | 128 | 164x |
| 20+ GB | util=0.9, seqs=128 | 128 | 170x |

### 9.2 按业务场景选择

| 场景 | 推荐配置 | 说明 |
|------|----------|------|
| 显存敏感 | util=0.4, seqs=128, len=2048 | 最省显存 |
| 短句高并发 | util=0.4, seqs=128, len=512 | 短文本场景 |
| 通用场景 | util=0.4, seqs=128, len=2048 | 默认推荐 |
| 极限性能 | util=0.9, seqs=128, len=2048 | 显存充足时 |

---

## 10. 注意事项

1. **util 最低 0.4** - 低于 0.4 会导致 KV Cache 不足
2. **seqs 对显存影响小** - 从 8 到 128 仅增加 ~400MB
3. **超并发会排队** - 超过 seqs 的请求不会失败，只是延迟增加
4. **TTFB 与并发正相关** - 高并发场景需权衡延迟
5. **长文本需要足够的 len** - 300+ 字需要 len≥1024

---

## 附录

### A. 测试脚本

| 脚本 | 用途 |
|------|------|
| `benchmark.py` | 基础参数组合测试 |
| `benchmark_fullload.py` | 满负载吞吐量测试 |
| `benchmark_limit.py` | 极限并发探索测试 |
| `test_ttfb.py` | TTFB 延迟测试 |
| `test_overload.py` | 超并发排队机制测试 |
| `test_low_util.py` | 低 util 极限测试 |
| `test_model_len.py` | max_model_len 影响测试 |

### B. 关键指标定义

| 指标 | 定义 | 计算公式 |
|------|------|----------|
| RTF | 实时因子 | 生成时间 / 音频时长 |
| 吞吐量 | 单位时间产出 | 总音频时长 / 总处理时间 |
| TTFB | 首字延迟 | 请求发出到收到第一个音频 chunk 的时间 |
| Wall Time | 墙钟时间 | 所有请求从开始到全部完成的时间 |

### C. 环境变量说明

```bash
# 模型路径
VOXCPM_MODEL_PATH=/home/estar/voxcpm-docker/VoxCPM1.5

# GPU 设备（相对索引，基于 CUDA_VISIBLE_DEVICES）
VOXCPM_DEVICES=0,1

# 显存利用率（推荐 0.4）
VOXCPM_GPU_MEMORY_UTILIZATION=0.4

# 最大并发序列数（推荐 128）
VOXCPM_MAX_NUM_SEQS=128

# 最大序列长度（根据文本长度选择）
VOXCPM_MAX_MODEL_LEN=2048
```
